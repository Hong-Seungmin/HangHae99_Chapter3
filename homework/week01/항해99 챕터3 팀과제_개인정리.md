# Spring PBL 1주차 팀 과제

🔐 JPA 가 무엇인가요?

```
- JAVA와 DBMS간의 연결 인터페이스 중 하나.
- JDBC를 이용한 인터페이스로 ORM 기술을 적용하여, 객체로 하여금 DB를 조작할 수 있다. 
```
[참고](https://gmlwjd9405.github.io/2019/08/04/what-is-jpa.html)

🔐 Controller, Service, Repository 가 무엇인가요?

```
- MVC 패턴에 이용하는 역할.
- client <--> controller // controller <--> service // service <--> repository // repository <--> DBMS
- controller : client와 직접 소통하며, 적절한 service를 호출하는 등 라우팅 담당
- service : 비즈니스 로직을 담당하여 repository를 이용해, controller의 요구에 맞는 데이터를 반환한다.
- repository : DBMS와 소통하며, service의 요구에 맞는 데이터를 반환한다.
```

🔐 restAPI의 put 과 patch 는 어떤 차이점이 있을까요? 어떤 경우에 사용하면 좋을까요?

```
- PUT : 데이터(객체)를 새로운 데이터로 갱신
- PATCH : 데이터(객체)의 일부분을 변경
```

🔐 우리가 브라우저에서 구매한 도메인 주소를 입력하면 만들어 놓은 aws EC2 서버까지 전달이 되어서 해당 서버에게 요청을 보낼 수 있습니다. 이 과정이 상세하게 어떻게 진행되는지 그림으로 한번 그려볼까요?

```
1. 브라우저 ==> DNS서버 : 도메인 주소 전송 ( IP 주소 요청 )
2. DNS서버 ==> 브라우저 : IP주소 반환
3. 브라우저 ==> 목적지 서버 : IP주소 접근
```

🔐 스프링 프레임워크는 어떤 특징 혹은 장점을 가지고 있나요? (3가지 이상)

```
1. 오픈소스
2. DI를 통한 객체 관리, 관계 구성
3. 컨테이너를 통한 객체 라이프사이클 관리
4. AOP 지원을 통한 생산성 향상
5. MVC 패턴을 활용한 역할 분담
```

🔐 스프링에서 DI (의존성 주입) 를 사용하는 이유가 무엇인가요? 예를 통해 설명 해 보세요.

```
-객체간의 결합도를 최소화하여 유연성을 높인다.
-객체간의 의존관계를 외부에서 공급함으로써 내부에서는 자유롭게 작업할 수 있다.

예) 정기 렌탈 서비스 (운전자 <==> 자동차)
- 운전자와 자동차에 대한 의존관계만 유지한다. (차량 종류에 대한 고민이 필요없다)
- 운전자는 렌탈업체에서 제공해주는 차량을 그대로 받아서 운행한다. (의존 주입)
- 운전자는 어떤 차량을 타야할지에 대한 고민이 없다. (고장이 나거나 질리면, 렌탈업체에서 관리해준다.)
- 차량이 바뀌어도 운전자는 액션을 취할것이 없다. (재사용 증가, 자동차에 대한 종속성 감소)  
- 차량 운행에 대한 인터페이스는 모두 동일하므로, 운행함에 있어서 바뀐부분은 없다. (결합도 감소)

의존성이 높을경우)
- 차량이 바뀔때마다 차량등록을 매번 해야한다. ( new MyCar() )
- 운전자는 특정 차량을 탈때마다 매뉴얼을 읽어야한다. (해당 차량의 기능을 써야한다) (차량들의 운행방법이 다르다는 전제)
- 차량의 운행기능의 변화가 발생하면, 다시 배워야한다. ( 결합도 증가 )
```
[참고](https://devlog-wjdrbs96.tistory.com/165)

🔐 스프링 시큐리티를 사용해 회원관리하는 방법을 순서도를 통해 정리해 보세요.

이론적으로 너무 다양해서? **스프링 시큐리티를 제대로 이해하지 못하였다.** 직접 써보면서 이해해야겠다.

- ###회원가입
![회원가입](https://github.com/Hong-Seungmin/HangHae99_Chapter3/blob/master/homework/images/%ED%95%AD%ED%95%B499%20%EC%B1%95%ED%84%B03%201%EC%A3%BC%EC%B0%A8%20%EA%B3%BC%EC%A0%9C-%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85.jpg?raw=true)

- ###로그인
![회원가입](https://github.com/Hong-Seungmin/HangHae99_Chapter3/blob/master/homework/images/%ED%95%AD%ED%95%B499%20%EC%B1%95%ED%84%B03%201%EC%A3%BC%EC%B0%A8%20%EA%B3%BC%EC%A0%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8.jpg?raw=true)

- ###로그인 유지
![회원가입](https://github.com/Hong-Seungmin/HangHae99_Chapter3/blob/master/homework/images/%ED%95%AD%ED%95%B499%20%EC%B1%95%ED%84%B03%201%EC%A3%BC%EC%B0%A8%20%EA%B3%BC%EC%A0%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EC%9C%A0%EC%A7%80.jpg?raw=true)


🔐 개발자 테스트 코드 작성 시 장/단점과 테스트 종류 별 (단위 테스트, 통합 테스트, E2E 테스트) 로 특징은?

```
테스트 코드 작성시 장,단점
-장점 : (유지보수가 쉬워진다.)
    - 개발 단계에서 문제점을 쉽게 찾을 수 있다. 
    - 변경점에 대한 오류 대처를 개발 단계에서 대비할 수 있다.
    - 설계적 오류를 미리 감지할 수 있다. (전체 재설계 방지)
    - 한번 작성한 테스트 코드는 비즈니스 로직이 바뀌어도 또 사용할 수 있다. (재사용)
    
-단점 : (테스트 코드 작성에 대한 비용 증가)
    - 테스트 코드 또한 작업물이므로 작업량이 증가한다.
    - 비즈니스 로직이 아닌, 비즈니스 목표가 바뀌면 해당 코드는 무쓸모이다. (종속적 부작용)
```
```
테스트 종류
- 단위 테스트 (모듈 테스트) :
    - 부품 하나하나 세밀하게 테스트함으로써, 문제영역을 확실하게 식별 가능하다. (기능적 오류)
    - 문제 발생 원인 추적이 쉽다. (모듈 단위)

- 통합 테스트 (환경 테스트) :
    - 여러 모듈들의 유기적인 환경에서 발생하는 문제영역을 범위적으로 식별 가능하다. (상황적 오류)
    - 문제 발생 원인 추적이 어렵다. (모듈들의 범위 단위)

- E2E 테스트 (상황 테스트) :
    - 유스케이스별 입출력 검증
    - 다양한(고려된, 고려되지 않은) 액션에 대한 처리 검증
    - 다양한(고려된, 고려되지 않은) 상황에 대한 처리 검증
```
[참고](https://velog.io/@jybin96/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%8B%9C-%EC%9E%A5%EB%8B%A8%EC%A0%90%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A2%85%EB%A5%98-%EB%B3%84-%ED%8A%B9%EC%A7%95)

🔐 ORM, JPA, Spring Data JPA 를 구분해서 설명해 보세요.

```
- ORM :
    - DBMS와 Object를 연결하여, 객체로 하여금 DBMS를 제어하는 기술이다.
    - 쿼리를 직접사용하지 않아도, DBMS를 이용할 수 있다. (sql을 배우지 않아도 된다.)
    - 변경점에 대한 유지보수가 쉽다.
    - 쿼리를 쓰지 않으므로, 다양한 DBMS에 대한 재사용성이 높다.
    
    - 오버헤드가 쿼리보다 크다.
    - 쿼리에 비해 원하는 출력을 보장 못할 수 있다. (제대로 사용하지 못할 경우)
    
- JPA :
    - 자바용 ORM 이다. JDBC와 객체를 연결해준다. ( JPA <==> JDBC <==> DBMS )
      * ( JPA <==> DBMS ) 도 가능하다. ex. 직접 쿼리 사용.
    
- Spring Data JPA :
    - 스프링 프레임워크용 JPA 이다.
    - 스프링의 특징을 살려서 쿼리(즉 JPA)를 사용할 수 있게 도와준다.
    (Spring JPA <==> JPA <==> JDBC <==> DBMS)
```

🔐 Optional) 절차지향 프로그래밍, 객체지향 프로그래밍,  관점지향 프로그래밍은 각각 어떻게 다른가요? (각각 예제 1개 이상)

- 절차지향 프로그래밍 : ( 순서에 맞게 데이터 흐름을 구성 )
    - 모든 비즈니스 로직이 연계 되어 있다.
    
    - 유지보수가 어렵다. (연계점을 확인해야한다.)
    - 효율적이다. (속도, 리소스 등)
```
main(){
while 살아있다(내 인생):
  아침 = 해가 뜬다(한국);
  배고픔 = 잠에서 깬다(아침);
  밥을 먹는다(아침, 배고픔);
  출근을 한다(회사);
  whilw 업무시간이다(회사):
    배고픔 += 일을 한다(회사);
    if 배가 고프다(회사):
      배고픔 -= 밥을 먹는다(회사, 점심);
  즐거움 += 퇴근을 한다(회사);
  저녁 = 해가 진다(한국);
  if 배가 고프다(집):
    밥을 먹는다(집, 저녁);
  월급 += 공부를 한다(집);
  즐거움 += 게임을 한다(집);
  다크써클 -= 잠을 잔다(저녁);
}
```

- 객체지향 프로그래밍 : ( 역할에 따라 데이터 관계를 구성 )
    - 공통된 역할의 비즈니스 로직을 모아 각각 관리한다.
    - 유지보수가 쉽다 (해당 역할에 대해서만 바꾸면 된다)
    
    - 오버헤드가 크다.
```
main(){
while 살아있다(내 인생):
  if 해.떳다():
    사람.잠에서 깬다();
  if 사람.일어났다() and 해.땟다() and 사람.배가 고프다():
    사람.밥을 먹는다();
  if 회사.출근 시간():
    사람.출근을 한다();
  사람.일한다();
  if 사람.배가 고프다():
    사람.밥을 먹는다();
  if 회사.퇴근시간():
    사람.퇴근을 한다();
  해.진다();
  사람.밥을 먹는다();
  사람.공부를 한다();
  사람.게임을 한다();
  사람.잠을 잔다();
}
```

- 관점지향 프로그래밍 : ( 상황에 따라 데이터 흐름을 구성 )
    - 공통된 상황적 비즈니스 로직을 통합 관리 한다.
    - 객체의 근본 비즈니스 로직만 책임지면 된다. (공통 로직은 별도 관리)

```
사람1 = new 사람() {해, 회사}
사람1.잠에서 깬다(); // 해가 떳으면 아침과 출근준비한다.
사람1.밥을 먹는다(); // 해가 떳으니 아침을 먹는다.
사람1.출근을 한다(); // 아침이니 출근시간에 출근한다.
사람1.밥을 먹는다(); // 업무중에 배고프면 밥먹는다.
사람1.퇴근한다();   // 퇴근시간이 되면 퇴근한다.
사람1.밥을 먹는다(); // 해가 졌으면 저녁을 먹는다.
...

----
해:
해.뜬다();
해.진다();

---
회사:
회사.출근시간();
회사.업무();
회사.점심시간();
회사.퇴근시간();
```

**막상 예시를 만들었는데... 뭔가 이상하다**